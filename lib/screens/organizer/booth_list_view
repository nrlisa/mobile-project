import 'package:flutter/material.dart';
import '../../services/db_service.dart';
import '../../services/auth_service.dart';
import '../../models/event_model.dart';
import '../../models/booth.dart'; //

class OrganizerBoothListView extends StatelessWidget {
  const OrganizerBoothListView({super.key});

  @override
  Widget build(BuildContext context) {
    final DbService dbService = DbService();
    final AuthService authService = AuthService();
    final String currentUid = authService.currentUser?.uid ?? "";

    return Scaffold(
      appBar: AppBar(title: const Text("Booth Inventory Summary"), centerTitle: true),
      body: currentUid.isEmpty 
        ? const Center(child: Text("User not logged in"))
        : FutureBuilder<dynamic>(
            // Fetch User Profile to get the correct 'organizerId'
            future: _getOrganizerId(currentUid), 
            builder: (context, userSnapshot) {
              if (userSnapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator());
              }
              final String orgId = userSnapshot.data ?? "";

              return StreamBuilder<List<EventModel>>(
                stream: dbService.getOrganizerEvents(orgId),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  
                  final events = snapshot.data ?? [];
                  if (events.isEmpty) {
                    return const Center(child: Text("No exhibitions found."));
                  }

                  return ListView.builder(
                    padding: const EdgeInsets.all(16),
                    itemCount: events.length,
                    itemBuilder: (context, index) {
                      final event = events[index];
                      return Card(
                        margin: const EdgeInsets.only(bottom: 12),
                        child: ExpansionTile(
                          title: Text(event.name, style: const TextStyle(fontWeight: FontWeight.bold)),
                          subtitle: Text(event.location),
                          children: [_buildBoothSummaryTable(event.id, dbService)],
                        ),
                      );
                    },
                  );
                },
              );
            },
          ),
    );
  }

  // Helper to get Organizer ID from User Collection
  Future<String> _getOrganizerId(String uid) async {
    // You might want to move this logic to AuthService or DbService
    // For now, assuming direct Firestore access or using DbService logic if available
    // Here we return UID as fallback, or fetch from Firestore if you have a method
    return uid; 
  }

  Widget _buildBoothSummaryTable(String eventId, DbService db) {
    return StreamBuilder<List<Booth>>(
      stream: db.getBoothsStream(eventId), // Uses the NEW method
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
           return const Padding(padding: EdgeInsets.all(16), child: CircularProgressIndicator());
        }

        final booths = snapshot.data ?? [];
        if (booths.isEmpty) {
          return const Padding(padding: EdgeInsets.all(16), child: Text("No booths generated yet."));
        }

        // AGGREGATE DATA: Group by Size
        final Map<String, Map<String, dynamic>> summary = {};

        for (var booth in booths) {
          if (!summary.containsKey(booth.size)) {
            summary[booth.size] = {
              'count': 0,
              'available': 0,
              'booked': 0,
              'price': booth.price,
            };
          }
          summary[booth.size]!['count'] += 1;
          if (booth.status == 'available') summary[booth.size]!['available'] += 1;
          if (booth.status == 'booked') summary[booth.size]!['booked'] += 1;
        }

        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Table(
            border: TableBorder.all(color: Colors.grey.shade300),
            columnWidths: const {
              0: FlexColumnWidth(2), // Type
              1: FlexColumnWidth(2), // Price
              2: FlexColumnWidth(1), // Total
              3: FlexColumnWidth(1), // Avail
            },
            children: [
              // Header
              const TableRow(decoration: BoxDecoration(color: Color(0xFFEEEEEE)), children: [
                Padding(padding: EdgeInsets.all(8), child: Text("Type", style: TextStyle(fontWeight: FontWeight.bold))),
                Padding(padding: EdgeInsets.all(8), child: Text("Price", style: TextStyle(fontWeight: FontWeight.bold))),
                Padding(padding: EdgeInsets.all(8), child: Text("Total", style: TextStyle(fontWeight: FontWeight.bold))),
                Padding(padding: EdgeInsets.all(8), child: Text("Free", style: TextStyle(fontWeight: FontWeight.bold))),
              ]),
              // Data Rows
              ...summary.entries.map((entry) {
                final size = entry.key;
                final data = entry.value;
                return TableRow(children: [
                  Padding(padding: const EdgeInsets.all(8), child: Text(size)),
                  Padding(padding: const EdgeInsets.all(8), child: Text("RM ${data['price']}")),
                  Padding(padding: const EdgeInsets.all(8), child: Text("${data['count']}")),
                  Padding(padding: const EdgeInsets.all(8), child: Text("${data['available']}", style: const TextStyle(color: Colors.green, fontWeight: FontWeight.bold))),
                ]);
              }),
            ],
          ),
        );
      },
    );
  }
}